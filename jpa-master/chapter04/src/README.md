# Chapter 04. 실전 예제 - 작은 쇼핑몰 만들기

작은 쇼핑몰을 만들어가면서 JPA로 실제 도메인 모델을 어떻게 구성하고 객체와 테이블을 어떻게 매핑해야 하는지 알아보자.
 여기서 완성된 도메인 모델로 웹 애플리케이션 만들기 장<sup>11장</sup>에서 실제 웹 애플리케이션을 만들어 볼것이다.

먼저 요구사항을 분석하고 도메인 모델과 테이블을 설계하자.



## 1. 요구사항 분석과 기본 매핑



### 요구사항 분석

핵심 요구사항은 다음과 같다.

- 회원은 상품을 주문할 수 있다.
- 주문 시 여러 종류의 상품을 선택할 수 있다.



> *메인 화면 (카카오 오븐 사용)*

<img src="https://user-images.githubusercontent.com/43429667/75961508-7de73100-5f05-11ea-990e-fbdd9533b6b1.png" alt="image" style="zoom:67%;" />

- **회원 기능**
  - 회원 등록
  - 회원 조회
- **상품 기능**
  - 상품 등록
  - 상품 수정
  - 상품 조회
- **주문 기능**
  - 상품 주문
  - 주문 내역 조회
  - 주문 취소



### 도메인 모델 분석

요구사항을 분석해보니 회원, 주문, 상품, 주문상품이라는 엔티티가 도출되었다.

> 실전 예제 1 UML

![image](https://user-images.githubusercontent.com/43429667/75962001-5cd31000-5f06-11ea-9c69-0afe59d3e58d.png)



- **회원과 주문의 관계**: 회원은 여러 번 주문할 수 있으므로 회원과 주문은 일대다 관계다.
- **주문과 상품의 관계**: 주문할 때 여러 상품을 함께 선택할 수 있고, 같은 상품도 여러 번 주문될 수 있으므로 다대다 관계다.
  주문 상품에는 해당 상품을 구매한 금액과 수량 정보가 포함되어 있다.



### 테이블 설계

> *실전 예제 1 ERD*

![image](https://user-images.githubusercontent.com/43429667/75963346-a7ee2280-5f08-11ea-826c-1309ff2fba9c.png)



- **회원<sup>MEMBER</sup>**: 이름과 주소 정보를 가진다.
- **주문<sup>ORDERS</sup>**: 상품을 주문한 회원을 외래 키로 가진다. 주문 상태는 주문과 취소를 표현할 수 있다.
- **주문 상품<sup>ORDER_ITEM</sup>**: 주문과 주문한 상품을 외래 키로 가진다. 주문 금액, 주문 수량 정보를 가진다.
- **상품<sup>ITEM</sup>**: 이름, 가격, 재고수량을 가진다. 상품을 주문하면 재고수량이 줄어든다.





### 엔티티 설계와 매핑

> *실전 예제1 UML 상세*

![image](https://user-images.githubusercontent.com/43429667/75964281-4b8c0280-5f0a-11ea-84bd-f5009927ca46.png)



> *Member 엔티티*

<script src="https://gist.github.com/9f4aa0aae58886ff21257d9770c39b1b.js"/>

예제에서는 PostgreSQL을 사용했고, 이 데이터베이스는 SEQUENCE를 자동으로 사용한다.



> *Order 엔티티*

<script src="https://gist.github.com/5d1c1a2cebafa199fe84d18341b630a7.js"/>



주문 날짜는 Date를 사용하고 년월일 시분초를 모두 사용하므로 TemporalType.TIMESTAMP 속성을 사용해서 매핑했다.
참고로 @Temporal의 기본 값은 TemporalType.TIMESTAMP이므로 생략해도 된다.

주문 상태는 EnumType.STRING 속성을 지정해서 열거형의 이름이 그대로 저장되도록 했다.



> *주문 상품 엔티티*

<script src="https://gist.github.com/MoochiPark/d20df77c89ade5241e45d6406a9055a0.js"></script>



> *Item 엔티티*

<script src="https://gist.github.com/MoochiPark/a0242336b17819a52001fb7aa74e967e.js"></script>



### 데이터 중심 설계의 문제점

객체 지향 설계는 각각의 객체가 맡은 역할과 책임이 있고 관련 있는 객체끼리 참조하도록 설계해야 한다.
지금 이 방식은 객체 설계를 테이블 설계에 맞춘 방법이다. 특히 테이블의 외래 키를 객체에 그대로 가져온 부분이 문제다.
왜냐하면 관계형 데이터베이스는 연관된 객체를 찾을 때 외래 키를 사용해서 조인하면 되지만 객체에는 조인이라는 기능이 없다.
객체는 연관된 객체를 찾을 때 참조를 사용해야 한다.

설계한 엔티티로 데이터베이스 스키마 자동 생성하기를 실행해보면 ERD에 나온대로 테이블이 생성 된다. 하지만 객체에서 참조 대신 데이터베이스의 외래 키를 그대로 가지고 있으므로 order.getMember()처럼 객체 그래프를 탐색할 수 없고 객체의 특성도 살릴 수 없다. 그리고 객체가 다른 객체를 참조하지도 않으므로 UML도 잘못되었다. 객체는 외래 키 대신에 참조를 사용해야 한다.

이렇게 외래 키만 가지고 있으면 연관된 엔티티를 찾을 때 외래 키로 데이터베이스를 다시 조회해야 한다.
예를 들어 주문을 조회한 다음 주문과 연관된 회원을 조회하려면 다음처럼 외래 키를 사용해서 다시 조회해야 한다.

```java
Order order = em.find(Order.class, orderId);
Member  member = em.find(Member.class, order.getMemberId()); // 외래 키로 다시 조회
```



객체는 참조를 사용해서 연관관계를 조회할 수 있다. 따라서 다음처럼 참조를 사용하는 것이 객체지향적인 방법이다.

```java
Order order = em.find(Order.class, orderId);
Member member = order.getMember(); // 참조 객체 사용
```

정리하자면 객체는 참조를 사용해서 연관된 객체를 찾고 테이블은 외래 키를 사용해서 연관된 테이블을 찾으므로 둘 사이에는
큰 차이가 있다.

JPA는 객체의 참조와 테이블의 외래키를 매핑해서 객체에서는 참조를 사용하고 테이블에서는 외래 키를 사용할 수 있도록 한다.
다음 장을 통해 참조와 외래 키를 어떻게 매핑하는지 보자.

